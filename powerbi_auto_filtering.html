<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Warehouse 3D Viewer - Updated</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; background: #f5f5f5; }
        #viewer { width: 100vw; height: 100vh; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>
    <div id="viewer"></div>

    <script>
        // âš ï¸ UPDATE THIS MAPPING BASED ON YOUR POWER BI DATA
        // Map your Power BI container names to the object names in the GLB file
        // The GLB file contains objects named: 1667, 1677, 2294, 1624, 1665, 1635, 1680, 1692, 1619, 1777
        const CONTAINER_NAME_MAP = {
            'Container_Red': '1667',      // Example: Update with actual mapping
            'Container_Green': '1677',    // Example: Update with actual mapping
            'Container_Blue': '2294',     // Example: Update with actual mapping
            'Container_Purple': '1624',   // Example: Update with actual mapping
            'Container_Cyan': '1665',     // Example: Update with actual mapping
            'Container_Yellow': '1635',   // Add more as needed
            'Container_Orange': '1680',   // Add more as needed
            'Container_Pink': '1692',     // Add more as needed
            'Container_Brown': '1619',    // Add more as needed
            'Container_Grey': '1777'      // Add more as needed
        };

        // Color scheme for highlighting
        const CONTAINER_COLORS = {
            'Container_Red': 0xff0000,
            'Container_Green': 0x00ff00,
            'Container_Blue': 0x0000ff,
            'Container_Purple': 0x800080,
            'Container_Cyan': 0x00ffff,
            'Container_Yellow': 0xffff00,
            'Container_Orange': 0xff8800,
            'Container_Pink': 0xff69b4,
            'Container_Brown': 0x8b4513,
            'Container_Grey': 0x808080
        };

        function getURLParameter(name) {
            const urlParams = new URLSearchParams(window.location.search);
            return urlParams.get(name);
        }

        const urlSelectedContainer = getURLParameter('container');
        console.log('ðŸŽ¯ Selected container from Power BI:', urlSelectedContainer);

        let scene, camera, renderer, controls;
        let model, allObjects = [];
        let glbLoaded = false;
        let pendingSelection = urlSelectedContainer;
        let originalMaterials = new Map();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf5f5f5);
            
            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(8, 6, 8);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.getElementById('viewer').appendChild(renderer.domElement);
            
            // Lighting
            scene.add(new THREE.AmbientLight(0xffffff, 0.9));
            
            const dirLight1 = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight1.position.set(10, 10, 5);
            dirLight1.castShadow = true;
            scene.add(dirLight1);
            
            const dirLight2 = new THREE.DirectionalLight(0xffffff, 0.5);
            dirLight2.position.set(-10, 5, -10);
            scene.add(dirLight2);
            
            // Ground
            const ground = new THREE.Mesh(
                new THREE.PlaneGeometry(30, 30),
                new THREE.MeshStandardMaterial({ color: 0xdddddd })
            );
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
            
            // Grid
            scene.add(new THREE.GridHelper(30, 30, 0xcccccc, 0xe0e0e0));
            
            // Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 1;
            controls.maxDistance = 100;
            
            loadGLB();
            animate();
            
            window.addEventListener('resize', onResize);
        }

        function loadGLB() {
            const loader = new THREE.GLTFLoader();
            
            // âš ï¸ UPDATE THIS URL to point to your hosted GLB file
            const glbUrl = 'https://sharifsharifzada.github.io/warehouse-3d-viewer/deneme.glb';
            
            console.log('ðŸ“¦ Loading GLB from:', glbUrl);
            
            loader.load(
                glbUrl,
                (gltf) => {
                    console.log('âœ… GLB Loaded Successfully!');
                    
                    model = gltf.scene;
                    scene.add(model);
                    
                    // Center model
                    const box = new THREE.Box3().setFromObject(model);
                    const center = box.getCenter(new THREE.Vector3());
                    const size = box.getSize(new THREE.Vector3());
                    model.position.set(-center.x, -box.min.y, -center.z);
                    
                    // Traverse and collect all objects
                    console.log('\nâ•â•â• SCANNING MODEL STRUCTURE â•â•â•');
                    model.traverse((child) => {
                        console.log(`Object: "${child.name}" | Type: ${child.type} | UUID: ${child.uuid}`);
                        
                        allObjects.push({
                            object: child,
                            name: child.name || '',
                            uuid: child.uuid,
                            type: child.type
                        });
                        
                        // Store original materials
                        if (child.isMesh) {
                            if (Array.isArray(child.material)) {
                                child.material.forEach((mat, idx) => {
                                    originalMaterials.set(`${child.uuid}_${idx}`, mat.clone());
                                });
                            } else {
                                originalMaterials.set(child.uuid, child.material.clone());
                            }
                        }
                    });
                    console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
                    console.log(`Total objects found: ${allObjects.length}`);
                    
                    // List all available object names
                    const objectNames = allObjects
                        .filter(obj => obj.name && obj.name !== 'Scene')
                        .map(obj => obj.name);
                    console.log('Available object names:', objectNames);
                    
                    // Fit camera
                    fitCamera();
                    
                    glbLoaded = true;
                    
                    // Apply selection if pending
                    if (pendingSelection) {
                        setTimeout(() => selectContainer(pendingSelection), 300);
                    }
                },
                (xhr) => {
                    const percent = (xhr.loaded / xhr.total * 100).toFixed(0);
                    console.log(`Loading progress: ${percent}%`);
                },
                (error) => {
                    console.error('âŒ Error loading GLB:', error);
                }
            );
        }

        function selectContainer(containerName) {
            if (!glbLoaded) {
                pendingSelection = containerName;
                return;
            }
            
            // If no container selected, reset to show whole warehouse
            if (!containerName || containerName === '') {
                console.log('ðŸ“¦ No container selected - showing whole warehouse');
                resetToFullView();
                return;
            }
            
            console.log('\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
            console.log('ðŸŽ¯ Selecting container:', containerName);
            
            // Get the object name from the mapping
            const objectName = CONTAINER_NAME_MAP[containerName];
            const color = CONTAINER_COLORS[containerName] || 0xff00ff;
            
            if (!objectName) {
                console.log('âŒ No mapping found for:', containerName);
                console.log('Available mappings:', Object.keys(CONTAINER_NAME_MAP));
                resetToFullView();
                return;
            }
            
            console.log(`Looking for object: "${objectName}"`);
            
            // Find objects matching the name
            const matchedObjects = allObjects.filter(obj => {
                // Exact match
                if (obj.name === objectName) {
                    console.log('âœ… EXACT MATCH:', obj.name, 'â†’ Type:', obj.type);
                    return true;
                }
                // Partial match (in case of naming variations)
                if (obj.name && obj.name.includes(objectName)) {
                    console.log('âœ… PARTIAL MATCH:', obj.name, 'â†’ Type:', obj.type);
                    return true;
                }
                return false;
            });
            
            console.log(`Found ${matchedObjects.length} matching object(s)`);
            
            // Reset all materials first
            allObjects.forEach(item => {
                if (item.object.isMesh) {
                    const originalMat = originalMaterials.get(item.object.uuid);
                    if (originalMat) {
                        item.object.material = originalMat.clone();
                    }
                }
            });
            
            if (matchedObjects.length > 0) {
                // Highlight all matched objects
                matchedObjects.forEach(item => {
                    if (item.object.isMesh) {
                        const highlightMat = new THREE.MeshStandardMaterial({
                            color: color,
                            emissive: color,
                            emissiveIntensity: 0.8,
                            roughness: 0.2,
                            metalness: 0.8
                        });
                        
                        if (Array.isArray(item.object.material)) {
                            item.object.material = item.object.material.map(() => highlightMat.clone());
                        } else {
                            item.object.material = highlightMat;
                        }
                        
                        console.log('âœ… Highlighted:', item.name);
                    }
                    
                    // Also highlight children
                    item.object.traverse((child) => {
                        if (child.isMesh && child !== item.object) {
                            const highlightMat = new THREE.MeshStandardMaterial({
                                color: color,
                                emissive: color,
                                emissiveIntensity: 0.8,
                                roughness: 0.2,
                                metalness: 0.8
                            });
                            child.material = highlightMat;
                            console.log('  âœ… Highlighted child mesh');
                        }
                    });
                });
                
                // Focus camera on the first matched object
                const firstMatch = matchedObjects[0].object;
                const box = new THREE.Box3().setFromObject(firstMatch);
                const center = box.getCenter(new THREE.Vector3());
                const size = box.getSize(new THREE.Vector3());
                const maxDim = Math.max(size.x, size.y, size.z);
                const dist = Math.max(maxDim * 3, 6);
                
                camera.position.set(
                    center.x + dist * 0.7,
                    center.y + dist * 0.6,
                    center.z + dist * 0.7
                );
                camera.lookAt(center);
                controls.target.copy(center);
                
                console.log('ðŸ“· Camera focused on object');
            } else {
                console.log('âŒ No objects matched the name:', objectName);
                console.log('Available object names:', 
                    allObjects
                        .filter(o => o.name && o.name !== 'Scene')
                        .map(o => o.name)
                );
                resetToFullView();
            }
            
            console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');
        }

        function resetToFullView() {
            console.log('ðŸ”„ Resetting to full warehouse view');
            
            // Reset all materials to original
            allObjects.forEach(item => {
                if (item.object.isMesh) {
                    const originalMat = originalMaterials.get(item.object.uuid);
                    if (originalMat) {
                        item.object.material = originalMat.clone();
                    }
                }
            });
            
            // Fit camera to show entire model
            fitCamera();
        }

        function fitCamera() {
            if (!model) return;
            const box = new THREE.Box3().setFromObject(model);
            const center = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z);
            const fov = camera.fov * (Math.PI / 180);
            const dist = Math.abs(maxDim / Math.tan(fov / 2)) * 2.0;
            
            camera.position.set(
                center.x + dist * 0.7,
                center.y + dist * 0.6,
                center.z + dist * 0.7
            );
            camera.lookAt(center);
            controls.target.copy(center);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        window.addEventListener('load', init);
    </script>
</body>
</html>
