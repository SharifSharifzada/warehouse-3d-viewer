<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Warehouse 3D Viewer - Secure</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; background: #f5f5f5; font-family: Arial, sans-serif; }
        #viewer { width: 100vw; height: 100vh; }
        #access-denied {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 9999;
        }
        #access-denied h1 {
            font-size: 48px;
            margin-bottom: 20px;
        }
        #access-denied p {
            font-size: 18px;
            opacity: 0.8;
        }
        .lock-icon {
            font-size: 100px;
            margin-bottom: 30px;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>
    <div id="access-denied">
        <div class="lock-icon">ðŸ”’</div>
        <h1>Access Denied</h1>
        <p>Unauthorized access to this resource</p>
    </div>
    <div id="viewer"></div>

    <script>
        const ACCESS_TOKEN = 'warehouse-secret-2024-xyz789';  // â† CHANGE THIS!
        
        // Token validation
        function getURLParameter(name) {
            const urlParams = new URLSearchParams(window.location.search);
            return urlParams.get(name);
        }
        
        function validateAccess() {
            const providedToken = getURLParameter('token');
            
            if (providedToken !== ACCESS_TOKEN) {
                console.error('ðŸš« Access denied - invalid token');
                document.getElementById('access-denied').style.display = 'flex';
                document.getElementById('viewer').style.display = 'none';
                return false;
            }
            
            console.log('âœ… Access granted');
            return true;
        }
        
        // Validate access before loading anything
        if (!validateAccess()) {
            throw new Error('Unauthorized');
        }
        
        // ====================================================================
        // REST OF THE CODE (Same as before, but now protected)
        // ====================================================================
        
        const urlSelectedContainer = getURLParameter('container');
        console.log('ðŸŽ¯ Selected container from Power BI:', urlSelectedContainer);

        let scene, camera, renderer, controls;
        let model, allObjects = [];
        let glbLoaded = false;
        let pendingSelection = urlSelectedContainer;
        let originalMaterials = new Map();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf5f5f5);
            
            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(50, 40, 50);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.getElementById('viewer').appendChild(renderer.domElement);
            
            // Lighting
            scene.add(new THREE.AmbientLight(0xffffff, 0.8));
            
            const dirLight1 = new THREE.DirectionalLight(0xffffff, 0.7);
            dirLight1.position.set(100, 100, 50);
            dirLight1.castShadow = true;
            scene.add(dirLight1);
            
            const dirLight2 = new THREE.DirectionalLight(0xffffff, 0.4);
            dirLight2.position.set(-100, 50, -100);
            scene.add(dirLight2);
            
            const dirLight3 = new THREE.DirectionalLight(0xffffff, 0.3);
            dirLight3.position.set(0, 50, 100);
            scene.add(dirLight3);
            
            // Ground
            const ground = new THREE.Mesh(
                new THREE.PlaneGeometry(500, 500),
                new THREE.MeshStandardMaterial({ color: 0xdddddd })
            );
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
            
            // Grid
            scene.add(new THREE.GridHelper(500, 100, 0xcccccc, 0xe0e0e0));
            
            // Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 5;
            controls.maxDistance = 500;
            
            loadGLB();
            animate();
            
            window.addEventListener('resize', onResize);
        }

        function loadGLB() {
            const loader = new THREE.GLTFLoader();
            
            // âš ï¸ UPDATE THIS URL to point to your hosted GLB file
            const glbUrl = 'https://sharifsharifzada.github.io/warehouse-3d-viewer/warehouse-3d.glb';
            
            console.log('ðŸ“¦ Loading warehouse GLB...');
            
            loader.load(
                glbUrl,
                (gltf) => {
                    console.log('âœ… GLB Loaded Successfully!');
                    
                    model = gltf.scene;
                    scene.add(model);
                    
                    // Center model
                    const box = new THREE.Box3().setFromObject(model);
                    const center = box.getCenter(new THREE.Vector3());
                    const size = box.getSize(new THREE.Vector3());
                    model.position.set(-center.x, -box.min.y, -center.z);
                    
                    console.log('â•â•â• SCANNING WAREHOUSE â•â•â•');
                    
                    // Traverse and collect all objects
                    let numericObjects = 0;
                    model.traverse((child) => {
                        const match = child.name?.match(/^(\d+)(?:\.(\d+))?$/);
                        const numericId = match ? parseInt(match[1]) : null;
                        
                        allObjects.push({
                            object: child,
                            name: child.name || '',
                            uuid: child.uuid,
                            type: child.type,
                            numericId: numericId
                        });
                        
                        if (numericId !== null) {
                            numericObjects++;
                        }
                        
                        // Store original materials
                        if (child.isMesh) {
                            if (Array.isArray(child.material)) {
                                child.material.forEach((mat, idx) => {
                                    originalMaterials.set(`${child.uuid}_${idx}`, mat.clone());
                                });
                            } else {
                                originalMaterials.set(child.uuid, child.material.clone());
                            }
                        }
                    });
                    
                    console.log(`Objects with numeric IDs: ${numericObjects}`);
                    
                    fitCamera();
                    glbLoaded = true;
                    
                    if (pendingSelection) {
                        setTimeout(() => selectContainer(pendingSelection), 500);
                    }
                },
                (xhr) => {
                    const percent = (xhr.loaded / xhr.total * 100).toFixed(0);
                    console.log(`Loading: ${percent}%`);
                },
                (error) => {
                    console.error('âŒ Error loading GLB:', error);
                }
            );
        }

        function selectContainer(containerIdentifier) {
            if (!glbLoaded) {
                console.log('â³ Model not loaded yet, pending selection:', containerIdentifier);
                pendingSelection = containerIdentifier;
                return;
            }
            
            // If no container selected, reset to show whole warehouse
            if (!containerIdentifier || containerIdentifier === '') {
                console.log('ðŸ“¦ No container selected - showing whole warehouse');
                resetToFullView();
                return;
            }
            
            console.log('\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
            console.log('ðŸŽ¯ Selecting container ID:', containerIdentifier);
            console.log('Type of received ID:', typeof containerIdentifier);
            
            // Parse container ID
            const targetId = parseInt(containerIdentifier);
            if (isNaN(targetId)) {
                console.log('âŒ Invalid container ID - must be numeric');
                console.log('Received:', containerIdentifier);
                resetToFullView();
                return;
            }
            
            console.log(`âœ“ Parsed target ID: ${targetId}`);
            
            // Debug: Show available IDs
            const availableIds = allObjects
                .filter(obj => obj.numericId !== null)
                .map(obj => obj.numericId)
                .filter((id, index, self) => self.indexOf(id) === index)
                .sort((a, b) => a - b);
            console.log(`Available IDs in model: ${availableIds.slice(0, 20).join(', ')}... (showing first 20)`);
            
            // Find all objects with matching numeric ID
            const matchedObjects = allObjects.filter(obj => {
                if (obj.numericId === targetId) {
                    console.log('âœ… MATCH FOUND:', obj.name, 'â†’ ID:', obj.numericId, 'â†’ Type:', obj.type);
                    return true;
                }
                return false;
            });
            
            console.log(`Found ${matchedObjects.length} matching object(s) for ID ${targetId}`);
            
            // Reset all materials AND hide all objects
            allObjects.forEach(item => {
                if (item.object.isMesh) {
                    // Reset material
                    const originalMat = originalMaterials.get(item.object.uuid);
                    if (originalMat) {
                        item.object.material = originalMat.clone();
                    }
                    // Hide all objects initially
                    item.object.visible = false;
                }
            });
            
            if (matchedObjects.length > 0) {
                // Highlight with bright red and make ONLY matched objects visible
                const color = 0xff0000;
                
                console.log('ðŸŽ¨ Highlighting and showing ONLY selected objects...');
                matchedObjects.forEach((item, index) => {
                    // Make visible
                    item.object.visible = true;
                    
                    // Also make sure parent objects are visible
                    let parent = item.object.parent;
                    while (parent) {
                        parent.visible = true;
                        parent = parent.parent;
                    }
                    
                    // Highlight
                    highlightObject(item.object, color);
                    console.log(`  ${index + 1}. Highlighted and showing: ${item.name}`);
                });
                
                // Focus camera MUCH CLOSER on the first matched object
                console.log('ðŸ“· Focusing camera (close zoom)...');
                focusCameraOnClose(matchedObjects[0].object);
                console.log('âœ… Camera focused on container (isolated view)');
            } else {
                console.log('âŒ No container found with ID:', targetId);
                console.log('ðŸ’¡ Available ID range:', Math.min(...availableIds), '-', Math.max(...availableIds));
                console.log('ðŸ’¡ Check if ID', targetId, 'exists in your GLB model');
                
                // Show all objects again if nothing matched
                resetToFullView();
            }
            
            console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');
        }

        function resetToFullView() {
            console.log('ðŸ”„ Resetting to full warehouse view');
            
            // Show all objects and reset materials
            allObjects.forEach(item => {
                if (item.object.isMesh) {
                    item.object.visible = true;
                    const originalMat = originalMaterials.get(item.object.uuid);
                    if (originalMat) {
                        item.object.material = originalMat.clone();
                    }
                }
            });
            
            fitCamera();
        }

        function focusCameraOnClose(object) {
            const box = new THREE.Box3().setFromObject(object);
            const center = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z);
            
            // VERY CLOSE zoom - 0.8x the object size for tight framing
            const dist = Math.max(maxDim * 0.8, 2);
            
            camera.position.set(
                center.x + dist * 0.6,
                center.y + dist * 0.7,  // Slightly from above
                center.z + dist * 0.6
            );
            camera.lookAt(center);
            controls.target.copy(center);
        }

        function highlightObject(object, color) {
            if (object.isMesh) {
                const highlightMat = new THREE.MeshStandardMaterial({
                    color: color,
                    emissive: color,
                    emissiveIntensity: 0.9,
                    roughness: 0.2,
                    metalness: 0.8
                });
                
                if (Array.isArray(object.material)) {
                    object.material = object.material.map(() => highlightMat.clone());
                } else {
                    object.material = highlightMat;
                }
            }
            
            object.traverse((child) => {
                if (child.isMesh && child !== object) {
                    const highlightMat = new THREE.MeshStandardMaterial({
                        color: color,
                        emissive: color,
                        emissiveIntensity: 0.9,
                        roughness: 0.2,
                        metalness: 0.8
                    });
                    child.material = highlightMat;
                }
            });
        }

        function resetMaterials() {
            allObjects.forEach(item => {
                if (item.object.isMesh) {
                    const originalMat = originalMaterials.get(item.object.uuid);
                    if (originalMat) {
                        item.object.material = originalMat.clone();
                    }
                }
            });
        }

        function focusCameraOn(object) {
            const box = new THREE.Box3().setFromObject(object);
            const center = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z);
            
            // Much closer zoom - reduced from 4x to 1.5x the object size
            const dist = Math.max(maxDim * 1.5, 3);  // Changed from 4 to 1.5
            
            camera.position.set(
                center.x + dist * 0.7,
                center.y + dist * 0.6,
                center.z + dist * 0.7
            );
            camera.lookAt(center);
            controls.target.copy(center);
        }

        function resetToFullView() {
            resetMaterials();
            fitCamera();
        }

        function fitCamera() {
            if (!model) return;
            const box = new THREE.Box3().setFromObject(model);
            const center = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z);
            const fov = camera.fov * (Math.PI / 180);
            const dist = Math.abs(maxDim / Math.tan(fov / 2)) * 1.5;
            
            camera.position.set(
                center.x + dist * 0.7,
                center.y + dist * 0.5,
                center.z + dist * 0.7
            );
            camera.lookAt(center);
            controls.target.copy(center);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        window.addEventListener('load', init);
    </script>
</body>
</html>
