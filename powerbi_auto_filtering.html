<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Warehouse 3D Viewer</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; background: #f5f5f5; }
        #viewer { width: 100vw; height: 100vh; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>
    <div id="viewer"></div>

    <script>
        // Match by GUID or Material Name instead of primitive ID
        const CONTAINER_MAP = {
            'Container_Red': { 
                guid: '407c48e0-f433-16b9-897c-ede17b5e8a37',
                materialName: 'test1',
                color: 0xff0000 
            },
            'Container_Green': { 
                guid: 'a356650-49fa-16cf-aac7-c5e3b7d4a4f9',
                materialName: 'test2',
                color: 0x00ff00 
            },
            'Container_Blue': { 
                guid: '17fc96a0-d7fe-11f0-8ab0-9339546166c3',
                materialName: 'test3',
                color: 0x0000ff 
            },
            'Container_Purple': { 
                guid: '022b8f90-e247-11f0-aacc-e9f91898e217',
                materialName: 'test',
                color: 0x800080 
            },
            'Container_Cyan': { 
                guid: 'edf19e580-e24a-11f0-aacc-e9f91898e217',
                materialName: 'test',
                color: 0x00ffff 
            }
        };

        function getURLParameter(name) {
            const urlParams = new URLSearchParams(window.location.search);
            return urlParams.get(name);
        }

        const urlSelectedContainer = getURLParameter('container');
        console.log('Selected:', urlSelectedContainer);

        let scene, camera, renderer, controls;
        let model, allMeshes = [];
        let glbLoaded = false;
        let pendingSelection = urlSelectedContainer;
        let originalMaterials = new Map();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf5f5f5);
            
            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(10, 8, 10);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.getElementById('viewer').appendChild(renderer.domElement);
            
            // Lighting
            scene.add(new THREE.AmbientLight(0xffffff, 0.9));
            const dirLight1 = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight1.position.set(10, 10, 5);
            scene.add(dirLight1);
            const dirLight2 = new THREE.DirectionalLight(0xffffff, 0.5);
            dirLight2.position.set(-10, 5, -10);
            scene.add(dirLight2);
            
            // Ground
            const ground = new THREE.Mesh(
                new THREE.PlaneGeometry(30, 30),
                new THREE.MeshStandardMaterial({ color: 0xdddddd })
            );
            ground.rotation.x = -Math.PI / 2;
            scene.add(ground);
            
            // Grid
            scene.add(new THREE.GridHelper(30, 30, 0xcccccc, 0xe0e0e0));
            
            // Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            
            loadGLB();
            animate();
            
            window.addEventListener('resize', onResize);
        }

        function loadGLB() {
            const loader = new THREE.GLTFLoader();
            const glbUrl = 'https://sharifsharifzada.github.io/warehouse-3d-viewer/WareHouseIDTest_05.glb';
            
            loader.load(
                glbUrl,
                (gltf) => {
                    model = gltf.scene;
                    scene.add(model);
                    
                    // Center model
                    const box = new THREE.Box3().setFromObject(model);
                    const center = box.getCenter(new THREE.Vector3());
                    const size = box.getSize(new THREE.Vector3());
                    model.position.set(-center.x, -center.y + size.y/2, -center.z);
                    
                    // Collect ALL meshes and their materials
                    model.traverse((child) => {
                        if (child.isMesh) {
                            // Store original materials
                            if (Array.isArray(child.material)) {
                                child.material.forEach((mat, idx) => {
                                    const key = `${child.uuid}_${idx}`;
                                    originalMaterials.set(key, mat.clone());
                                    
                                    allMeshes.push({
                                        mesh: child,
                                        materialIndex: idx,
                                        materialName: mat.name,
                                        meshName: child.name
                                    });
                                    
                                    console.log('Found:', child.name, '→ Material:', mat.name);
                                });
                            } else {
                                const key = child.uuid;
                                originalMaterials.set(key, child.material.clone());
                                
                                allMeshes.push({
                                    mesh: child,
                                    materialIndex: -1,
                                    materialName: child.material.name,
                                    meshName: child.name
                                });
                                
                                console.log('Found:', child.name, '→ Material:', child.material.name);
                            }
                        }
                    });
                    
                    console.log('Total meshes:', allMeshes.length);
                    
                    // Fit camera to show all containers
                    fitCamera();
                    
                    glbLoaded = true;
                    
                    // Apply selection
                    if (pendingSelection) {
                        setTimeout(() => selectContainer(pendingSelection), 200);
                    }
                }
            );
        }

        function selectContainer(containerName) {
            if (!glbLoaded) {
                pendingSelection = containerName;
                return;
            }
            
            console.log('═══════════════════════');
            console.log('Selecting:', containerName);
            
            const containerInfo = CONTAINER_MAP[containerName];
            if (!containerInfo) {
                console.log('Container not in map');
                return;
            }
            
            console.log('Looking for material:', containerInfo.materialName);
            
            // Reset all materials first
            allMeshes.forEach((item) => {
                const key = item.materialIndex >= 0 
                    ? `${item.mesh.uuid}_${item.materialIndex}` 
                    : item.mesh.uuid;
                const originalMat = originalMaterials.get(key);
                
                if (originalMat) {
                    if (item.materialIndex >= 0) {
                        item.mesh.material[item.materialIndex] = originalMat.clone();
                    } else {
                        item.mesh.material = originalMat.clone();
                    }
                }
            });
            
            // Find and highlight matching material
            const matchingMeshes = allMeshes.filter(item => 
                item.materialName === containerInfo.materialName
            );
            
            console.log('Found', matchingMeshes.length, 'matching meshes');
            
            if (matchingMeshes.length > 0) {
                // Highlight all matching meshes with the container color
                matchingMeshes.forEach((item) => {
                    const highlightMat = new THREE.MeshStandardMaterial({
                        color: containerInfo.color,
                        emissive: containerInfo.color,
                        emissiveIntensity: 0.7,
                        roughness: 0.2,
                        metalness: 0.8
                    });
                    
                    if (item.materialIndex >= 0) {
                        item.mesh.material[item.materialIndex] = highlightMat;
                    } else {
                        item.mesh.material = highlightMat;
                    }
                });
                
                // Focus camera on first matching mesh
                const firstMatch = matchingMeshes[0];
                const box = new THREE.Box3().setFromObject(firstMatch.mesh);
                const center = box.getCenter(new THREE.Vector3());
                const size = box.getSize(new THREE.Vector3());
                const maxDim = Math.max(size.x, size.y, size.z);
                const dist = Math.max(maxDim * 3, 6);
                
                camera.position.set(
                    center.x + dist * 0.7,
                    center.y + dist * 0.6,
                    center.z + dist * 0.7
                );
                camera.lookAt(center);
                controls.target.copy(center);
                
                console.log('✅ Highlighted and focused');
            } else {
                console.log('❌ No matching meshes found');
            }
            
            console.log('═══════════════════════');
        }

        function fitCamera() {
            if (!model) return;
            const box = new THREE.Box3().setFromObject(model);
            const center = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z);
            const fov = camera.fov * (Math.PI / 180);
            const dist = Math.abs(maxDim / Math.tan(fov / 2)) * 2.0;
            camera.position.set(
                center.x + dist * 0.7,
                center.y + dist * 0.6,
                center.z + dist * 0.7
            );
            camera.lookAt(center);
            controls.target.copy(center);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        window.addEventListener('load', init);
    </script>
</body>
</html>
