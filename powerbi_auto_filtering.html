<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Warehouse 3D Viewer - Power BI</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: Arial, sans-serif;
            background: #f5f5f5;
            overflow: hidden;
        }
        
        #viewer-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        #viewer {
            width: 100%;
            height: 100%;
        }
        
        .info-overlay {
            position: absolute;
            top: 15px;
            left: 15px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px 20px;
            border-radius: 8px;
            box-shadow: 0 2px 12px rgba(0,0,0,0.15);
            z-index: 1000;
            min-width: 250px;
        }
        
        .info-overlay h3 {
            font-size: 14px;
            color: #0078d4;
            margin-bottom: 10px;
            font-weight: 600;
        }
        
        .info-row {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            font-size: 12px;
            border-bottom: 1px solid #f0f0f0;
        }
        
        .info-label {
            color: #666;
            font-weight: 500;
        }
        
        .info-value {
            color: #333;
            font-weight: 600;
        }
        
        .status-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
            margin-top: 8px;
        }
        
        .status-loading {
            background: #fff4ce;
            color: #8a6d3b;
        }
        
        .status-success {
            background: #dff6dd;
            color: #107c10;
        }
        
        .status-error {
            background: #f8d7da;
            color: #721c24;
        }
        
        .controls-hint {
            position: absolute;
            bottom: 15px;
            right: 15px;
            background: rgba(255, 255, 255, 0.9);
            padding: 8px 15px;
            border-radius: 6px;
            font-size: 11px;
            color: #666;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>
    <div id="viewer-container">
        <div id="viewer"></div>
        
        <div class="info-overlay">
            <h3>üì¶ Container Selection</h3>
            <div class="info-row">
                <span class="info-label">URL Parameter:</span>
                <span class="info-value" id="url-param">None</span>
            </div>
            <div class="info-row">
                <span class="info-label">Selected:</span>
                <span class="info-value" id="selected-name">None</span>
            </div>
            <div class="info-row">
                <span class="info-label">Status:</span>
                <span class="info-value" id="selected-status">-</span>
            </div>
            <div class="info-row">
                <span class="info-label">Value:</span>
                <span class="info-value" id="selected-value">-</span>
            </div>
            <div id="loading-status" class="status-badge status-loading">Loading model...</div>
        </div>
        
        <div class="controls-hint">
            üñ±Ô∏è Drag to rotate ‚Ä¢ Right-click drag to pan ‚Ä¢ Scroll to zoom
        </div>
    </div>

    <script>
        // ========== CONFIGURATION - Matches your friend's GLB structure EXACTLY ==========
        const CONTAINER_MAP = {
            'Container_Red': { id: 1, primitiveID: 0, materialName: 'test1', color: 0xff6b6b, value: 100, status: 'Active' },
            'Container_Green': { id: 2, primitiveID: 1, materialName: 'test2', color: 0x4ecdc4, value: 200, status: 'Active' },
            'Container_Blue': { id: 3, primitiveID: 2, materialName: 'test3', color: 0x45b7d1, value: 300, status: 'Active' },
            'Container_Purple': { id: 4, primitiveID: 3, materialName: 'test', color: 0xb088f9, value: 400, status: 'Active' },
            'Container_Cyan': { id: 5, primitiveID: 4, materialName: 'test', color: 0x00d9ff, value: 500, status: 'Active' }
        };

        // Get URL parameter from Power BI
        function getURLParameter(name) {
            const urlParams = new URLSearchParams(window.location.search);
            return urlParams.get(name);
        }

        const urlSelectedContainer = getURLParameter('container');
        console.log('URL Parameter:', urlSelectedContainer);
        
        if (urlSelectedContainer) {
            document.getElementById('url-param').textContent = urlSelectedContainer;
        }

        // ========== THREE.JS SETUP ==========
        let scene, camera, renderer, controls;
        let model = null;
        let primitives = [];
        let glbLoaded = false;
        let pendingSelection = urlSelectedContainer;

        function init() {
            const container = document.getElementById('viewer');
            
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf5f5f5);
            
            // Camera
            camera = new THREE.PerspectiveCamera(50, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(8, 6, 8);
            
            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.shadowMap.enabled = true;
            container.appendChild(renderer.domElement);
            
            // Lights
            scene.add(new THREE.AmbientLight(0xffffff, 0.7));
            
            const dirLight1 = new THREE.DirectionalLight(0xffffff, 0.5);
            dirLight1.position.set(10, 10, 5);
            dirLight1.castShadow = true;
            scene.add(dirLight1);
            
            const dirLight2 = new THREE.DirectionalLight(0xffffff, 0.3);
            dirLight2.position.set(-10, 5, -10);
            scene.add(dirLight2);
            
            // Ground
            const ground = new THREE.Mesh(
                new THREE.PlaneGeometry(20, 20),
                new THREE.MeshStandardMaterial({ color: 0xdddddd })
            );
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
            
            // Grid
            scene.add(new THREE.GridHelper(20, 20, 0xcccccc, 0xe0e0e0));
            
            // Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.target.set(0, 0, 0);
            
            // Load your friend's GLB (no changes to the file!)
            loadGLB();
            
            // Animation loop
            animate();
            
            // Handle resize
            window.addEventListener('resize', onResize);
        }

        function loadGLB() {
            const loader = new THREE.GLTFLoader();
            const glbUrl = 'https://sharifsharifzada.github.io/warehouse-3d-viewer/WareHouseIDTest_05.glb';
            
            console.log('Loading GLB:', glbUrl);
            updateStatus('Loading model...', 'loading');
            
            loader.load(
                glbUrl,
                (gltf) => {
                    console.log('‚úÖ GLB Loaded');
                    updateStatus('Model loaded', 'success');
                    
                    model = gltf.scene;
                    scene.add(model);
                    
                    // Center model
                    const box = new THREE.Box3().setFromObject(model);
                    const center = box.getCenter(new THREE.Vector3());
                    const size = box.getSize(new THREE.Vector3());
                    model.position.set(-center.x, -center.y + size.y/2, -center.z);
                    
                    // Extract primitives
                    extractPrimitives();
                    
                    // Fit camera
                    fitCamera();
                    
                    glbLoaded = true;
                    
                    // Apply pending selection from Power BI
                    if (pendingSelection) {
                        console.log('Applying pending selection:', pendingSelection);
                        setTimeout(() => selectContainer(pendingSelection), 100);
                    }
                },
                (xhr) => {
                    const progress = (xhr.loaded / xhr.total * 100).toFixed(0);
                    console.log(`Loading: ${progress}%`);
                },
                (error) => {
                    console.error('‚ùå GLB Load Error:', error);
                    updateStatus('Failed to load model', 'error');
                }
            );
        }

        function extractPrimitives() {
            let primitiveIndex = 0;
            
            model.traverse((child) => {
                if (child.isMesh) {
                    if (Array.isArray(child.material)) {
                        child.material.forEach((mat, idx) => {
                            primitives.push({
                                primitiveID: primitiveIndex,
                                mesh: child,
                                materialIndex: idx,
                                materialName: mat.name,
                                originalMaterial: mat.clone()
                            });
                            primitiveIndex++;
                        });
                    } else {
                        primitives.push({
                            primitiveID: primitiveIndex,
                            mesh: child,
                            materialIndex: -1,
                            materialName: child.material.name,
                            originalMaterial: child.material.clone()
                        });
                        primitiveIndex++;
                    }
                }
            });
            
            console.log(`Extracted ${primitives.length} primitives`);
        }

        function selectContainer(containerName) {
            console.log('Selecting:', containerName);
            
            if (!glbLoaded) {
                console.log('GLB not loaded yet, storing selection');
                pendingSelection = containerName;
                return;
            }
            
            const containerInfo = CONTAINER_MAP[containerName];
            if (!containerInfo) {
                console.error('Container not found:', containerName);
                updateStatus('Container not found', 'error');
                return;
            }
            
            console.log('Container info:', containerInfo);
            
            // Find primitive
            const prim = primitives.find(p => p.primitiveID === containerInfo.primitiveID);
            
            if (!prim) {
                console.error('Primitive not found:', containerInfo.primitiveID);
                updateStatus('Container mesh not found', 'error');
                return;
            }
            
            console.log('Found primitive:', prim);
            
            // Reset all materials (dim others)
            primitives.forEach((p) => {
                if (p.materialIndex >= 0) {
                    p.mesh.material[p.materialIndex] = p.originalMaterial.clone();
                    p.mesh.material[p.materialIndex].opacity = 0.3;
                    p.mesh.material[p.materialIndex].transparent = true;
                } else {
                    p.mesh.material = p.originalMaterial.clone();
                    p.mesh.material.opacity = 0.3;
                    p.mesh.material.transparent = true;
                }
            });
            
            // Highlight selected
            const highlightMat = new THREE.MeshStandardMaterial({
                color: containerInfo.color,
                emissive: containerInfo.color,
                emissiveIntensity: 0.6,
                roughness: 0.2,
                metalness: 0.7,
                transparent: false,
                opacity: 1.0
            });
            
            if (prim.materialIndex >= 0) {
                prim.mesh.material[prim.materialIndex] = highlightMat;
            } else {
                prim.mesh.material = highlightMat;
            }
            
            // Focus camera on selected container
            const box = new THREE.Box3().setFromObject(prim.mesh);
            const center = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3());
            
            const maxDim = Math.max(size.x, size.y, size.z);
            const dist = maxDim * 3;
            
            camera.position.set(
                center.x + dist * 0.7,
                center.y + dist * 0.5,
                center.z + dist * 0.7
            );
            camera.lookAt(center);
            controls.target.copy(center);
            
            // Update UI
            document.getElementById('selected-name').textContent = containerName;
            document.getElementById('selected-status').textContent = containerInfo.status;
            document.getElementById('selected-value').textContent = containerInfo.value;
            updateStatus('Focused on ' + containerName, 'success');
            
            console.log('‚úÖ Selection complete');
        }

        function fitCamera() {
            if (!model) return;
            
            const box = new THREE.Box3().setFromObject(model);
            const center = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3());
            
            const maxDim = Math.max(size.x, size.y, size.z);
            const fov = camera.fov * (Math.PI / 180);
            const dist = Math.abs(maxDim / Math.tan(fov / 2)) * 1.5;
            
            camera.position.set(
                center.x + dist * 0.7,
                center.y + dist * 0.5,
                center.z + dist * 0.7
            );
            camera.lookAt(center);
            controls.target.copy(center);
        }

        function updateStatus(message, type) {
            const statusDiv = document.getElementById('loading-status');
            statusDiv.textContent = message;
            statusDiv.className = `status-badge status-${type}`;
            console.log(message);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        function onResize() {
            const container = document.getElementById('viewer');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        // Start everything
        window.addEventListener('load', init);
    </script>
</body>
</html>
