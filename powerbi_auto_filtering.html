<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Warehouse 3D Viewer - Complete</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: Arial, sans-serif; background: #f5f5f5; overflow: hidden; }
        
        #viewer-container { width: 100vw; height: 100vh; position: relative; }
        #viewer { width: 100%; height: 100%; }
        
        .info-overlay {
            position: absolute;
            top: 15px;
            left: 15px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px 20px;
            border-radius: 8px;
            box-shadow: 0 2px 12px rgba(0,0,0,0.15);
            z-index: 1000;
            min-width: 280px;
        }
        
        .info-overlay h3 {
            font-size: 14px;
            color: #0078d4;
            margin-bottom: 10px;
            font-weight: 600;
        }
        
        .info-row {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            font-size: 12px;
            border-bottom: 1px solid #f0f0f0;
        }
        
        .info-label { color: #666; font-weight: 500; }
        .info-value { color: #333; font-weight: 600; }
        
        .status-badge {
            display: inline-block;
            padding: 6px 14px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
            margin-top: 8px;
        }
        
        .status-loading { background: #fff4ce; color: #8a6d3b; }
        .status-success { background: #dff6dd; color: #107c10; }
        .status-error { background: #f8d7da; color: #721c24; }
        .status-info { background: #d1ecf1; color: #0c5460; }
        
        .controls-hint {
            position: absolute;
            bottom: 15px;
            right: 15px;
            background: rgba(255, 255, 255, 0.9);
            padding: 8px 15px;
            border-radius: 6px;
            font-size: 11px;
            color: #666;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        button {
            background: #0078d4;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 11px;
            cursor: pointer;
            margin-top: 8px;
        }

        button:hover {
            background: #106ebe;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>
    <div id="viewer-container">
        <div id="viewer"></div>
        
        <div class="info-overlay">
            <h3>üè≠ Warehouse Viewer</h3>
            <div class="info-row">
                <span class="info-label">Selection:</span>
                <span class="info-value" id="selected-name">All Containers</span>
            </div>
            <div class="info-row">
                <span class="info-label">Primitives:</span>
                <span class="info-value" id="primitive-count">Loading...</span>
            </div>
            <div class="info-row">
                <span class="info-label">Value:</span>
                <span class="info-value" id="selected-value">-</span>
            </div>
            <div id="loading-status" class="status-badge status-loading">Loading...</div>
            <button onclick="resetView()">üîÑ Reset View</button>
        </div>
        
        <div class="controls-hint">
            üñ±Ô∏è Drag to rotate ‚Ä¢ Right-click to pan ‚Ä¢ Scroll to zoom
        </div>
    </div>

    <script>
        // MANUAL MAPPING - You need to tell us which primitive = which container
        // We'll auto-detect after you test, but for now:
        const CONTAINER_MAP = {
            'Container_Red': { primitiveID: 0, color: 0xff0000, value: 100 },      // You confirmed this works
            'Container_Green': { primitiveID: 1, color: 0x00ff00, value: 200 },    // Needs verification
            'Container_Blue': { primitiveID: 2, color: 0x0000ff, value: 300 },     // You confirmed this works
            'Container_Purple': { primitiveID: 3, color: 0x800080, value: 400 },   // Needs verification
            'Container_Cyan': { primitiveID: 4, color: 0x00ffff, value: 500 }      // Needs verification
        };

        function getURLParameter(name) {
            const urlParams = new URLSearchParams(window.location.search);
            return urlParams.get(name);
        }

        const urlSelectedContainer = getURLParameter('container');
        console.log('üìç URL Parameter:', urlSelectedContainer);

        let scene, camera, renderer, controls;
        let model = null;
        let primitives = [];
        let glbLoaded = false;
        let pendingSelection = urlSelectedContainer;
        let originalCameraPosition = null;
        let originalControlsTarget = null;

        function init() {
            const container = document.getElementById('viewer');
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf5f5f5);
            
            camera = new THREE.PerspectiveCamera(50, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(10, 8, 10);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.shadowMap.enabled = true;
            container.appendChild(renderer.domElement);
            
            // BRIGHT LIGHTING to see everything
            scene.add(new THREE.AmbientLight(0xffffff, 0.9));
            
            const dirLight1 = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight1.position.set(10, 10, 5);
            scene.add(dirLight1);
            
            const dirLight2 = new THREE.DirectionalLight(0xffffff, 0.5);
            dirLight2.position.set(-10, 5, -10);
            scene.add(dirLight2);
            
            const dirLight3 = new THREE.DirectionalLight(0xffffff, 0.3);
            dirLight3.position.set(0, -5, 0);
            scene.add(dirLight3);
            
            // Ground
            const ground = new THREE.Mesh(
                new THREE.PlaneGeometry(30, 30),
                new THREE.MeshStandardMaterial({ color: 0xdddddd })
            );
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
            
            // Large grid
            scene.add(new THREE.GridHelper(30, 30, 0xcccccc, 0xe0e0e0));
            
            // Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.target.set(0, 0, 0);
            
            loadGLB();
            animate();
            
            window.addEventListener('resize', onResize);
        }

        function loadGLB() {
            const loader = new THREE.GLTFLoader();
            const glbUrl = 'https://sharifsharifzada.github.io/warehouse-3d-viewer/WareHouseIDTest_05.glb';
            
            console.log('üì¶ Loading GLB...');
            updateStatus('Loading model...', 'loading');
            
            loader.load(
                glbUrl,
                (gltf) => {
                    console.log('‚úÖ GLB Loaded!');
                    updateStatus('Model loaded', 'success');
                    
                    model = gltf.scene;
                    scene.add(model);
                    
                    // Center the entire model
                    const box = new THREE.Box3().setFromObject(model);
                    const center = box.getCenter(new THREE.Vector3());
                    const size = box.getSize(new THREE.Vector3());
                    
                    console.log('üìê Model size:', size.x.toFixed(2), 'x', size.y.toFixed(2), 'x', size.z.toFixed(2));
                    console.log('üìç Model center:', center.x.toFixed(2), center.y.toFixed(2), center.z.toFixed(2));
                    
                    // Move to origin but keep above ground
                    model.position.set(-center.x, -center.y + size.y/2, -center.z);
                    
                    // Extract all primitives
                    extractPrimitives();
                    
                    // Save original camera view (full warehouse view)
                    fitCameraToFullModel();
                    originalCameraPosition = camera.position.clone();
                    originalControlsTarget = controls.target.clone();
                    
                    glbLoaded = true;
                    
                    // Apply selection if URL parameter exists
                    if (pendingSelection) {
                        console.log('‚è≥ Pending selection:', pendingSelection);
                        setTimeout(() => selectContainer(pendingSelection), 200);
                    } else {
                        console.log('‚úÖ Showing full warehouse');
                        updateStatus('Showing all containers', 'info');
                    }
                },
                (xhr) => {
                    const progress = (xhr.loaded / xhr.total * 100).toFixed(0);
                    console.log(`Loading: ${progress}%`);
                },
                (error) => {
                    console.error('‚ùå Error:', error);
                    updateStatus('Failed to load', 'error');
                }
            );
        }

        function extractPrimitives() {
            let primitiveIndex = 0;
            
            model.traverse((child) => {
                if (child.isMesh) {
                    console.log(`üîç Mesh: ${child.name}`);
                    
                    if (Array.isArray(child.material)) {
                        child.material.forEach((mat, idx) => {
                            primitives.push({
                                primitiveID: primitiveIndex,
                                mesh: child,
                                materialIndex: idx,
                                materialName: mat.name,
                                originalMaterial: mat.clone()
                            });
                            console.log(`  ‚îú‚îÄ Primitive ${primitiveIndex}: ${mat.name} [Material ${idx}]`);
                            primitiveIndex++;
                        });
                    } else {
                        primitives.push({
                            primitiveID: primitiveIndex,
                            mesh: child,
                            materialIndex: -1,
                            materialName: child.material.name,
                            originalMaterial: child.material.clone()
                        });
                        console.log(`  ‚îî‚îÄ Primitive ${primitiveIndex}: ${child.material.name} [Single]`);
                        primitiveIndex++;
                    }
                }
            });
            
            console.log(`‚úÖ Total primitives: ${primitives.length}`);
            document.getElementById('primitive-count').textContent = primitives.length;
        }

        function selectContainer(containerName) {
            console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            console.log('üéØ SELECT:', containerName);
            console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            
            if (!glbLoaded) {
                pendingSelection = containerName;
                return;
            }
            
            const containerInfo = CONTAINER_MAP[containerName];
            if (!containerInfo) {
                console.error('‚ùå Not in CONTAINER_MAP:', containerName);
                updateStatus('Container not found', 'error');
                return;
            }
            
            console.log('‚úÖ Container info:', containerInfo);
            
            const prim = primitives.find(p => p.primitiveID === containerInfo.primitiveID);
            
            if (!prim) {
                console.error('‚ùå Primitive not found:', containerInfo.primitiveID);
                console.log('Available:', primitives.map(p => `P${p.primitiveID}:${p.materialName}`));
                updateStatus('Primitive not found', 'error');
                return;
            }
            
            console.log('‚úÖ Found primitive:', prim);
            
            // Reset all materials to original
            primitives.forEach((p) => {
                if (p.materialIndex >= 0) {
                    p.mesh.material[p.materialIndex] = p.originalMaterial.clone();
                } else {
                    p.mesh.material = p.originalMaterial.clone();
                }
            });
            
            // Highlight the selected one
            const highlightMat = new THREE.MeshStandardMaterial({
                color: containerInfo.color,
                emissive: containerInfo.color,
                emissiveIntensity: 0.8,
                roughness: 0.1,
                metalness: 0.9
            });
            
            if (prim.materialIndex >= 0) {
                prim.mesh.material[prim.materialIndex] = highlightMat;
            } else {
                prim.mesh.material = highlightMat;
            }
            
            // Zoom camera to this container
            const box = new THREE.Box3().setFromObject(prim.mesh);
            const center = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z);
            const dist = Math.max(maxDim * 3, 6);
            
            camera.position.set(
                center.x + dist * 0.7,
                center.y + dist * 0.6,
                center.z + dist * 0.7
            );
            camera.lookAt(center);
            controls.target.copy(center);
            
            // Update UI
            document.getElementById('selected-name').textContent = containerName;
            document.getElementById('selected-value').textContent = containerInfo.value;
            updateStatus('Focused on ' + containerName, 'success');
            
            console.log('‚úÖ Selection complete');
        }

        function resetView() {
            console.log('üîÑ Resetting to full view');
            
            // Reset all materials
            primitives.forEach((p) => {
                if (p.materialIndex >= 0) {
                    p.mesh.material[p.materialIndex] = p.originalMaterial.clone();
                } else {
                    p.mesh.material = p.originalMaterial.clone();
                }
            });
            
            // Restore original camera position
            if (originalCameraPosition && originalControlsTarget) {
                camera.position.copy(originalCameraPosition);
                controls.target.copy(originalControlsTarget);
            } else {
                fitCameraToFullModel();
            }
            
            document.getElementById('selected-name').textContent = 'All Containers';
            document.getElementById('selected-value').textContent = '-';
            updateStatus('Showing all containers', 'info');
        }

        function fitCameraToFullModel() {
            if (!model) return;
            
            const box = new THREE.Box3().setFromObject(model);
            const center = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3());
            
            const maxDim = Math.max(size.x, size.y, size.z);
            const fov = camera.fov * (Math.PI / 180);
            const dist = Math.abs(maxDim / Math.tan(fov / 2)) * 2.0; // 2.0 = zoom out more to see everything
            
            camera.position.set(
                center.x + dist * 0.7,
                center.y + dist * 0.6,
                center.z + dist * 0.7
            );
            camera.lookAt(center);
            controls.target.copy(center);
            
            console.log('üì∑ Camera fitted to full model');
        }

        function updateStatus(message, type) {
            const statusDiv = document.getElementById('loading-status');
            statusDiv.textContent = message;
            statusDiv.className = `status-badge status-${type}`;
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        function onResize() {
            const container = document.getElementById('viewer');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        window.addEventListener('load', init);
    </script>
</body>
</html>
